{"version":3,"sources":["index.ts"],"names":["fetch","then","res","text","gexf","graph","parse","Graph","container","document","getElementById","zoomInBtn","zoomOutBtn","zoomResetBtn","searchInput","searchSuggestions","renderer","Sigma","minCameraRatio","maxCameraRatio","allowInvalidContainer","renderEdgeLabels","camera","getCamera","addEventListener","animatedZoom","duration","animatedUnzoom","animatedReset","state","searchQuery","setSearchQuery","query","value","lcQuery","toLowerCase","suggestions","nodes","map","n","id","label","getNodeAttribute","filter","includes","length","selectedNode","setHoveredNode","undefined","clickMode","clickedNode","nodePosition","getNodeDisplayData","animate","Set","refresh","node","hoveredNode","hoveredNeighbors","neighbors","innerHTML","join","on","window","open","setSetting","data","has","color","highlighted","edge","hasExtremity","hidden","source","target"],"mappings":"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","file":"static/js/main.879154f7.chunk.js","sourcesContent":["/**\n * This example shows how to load a GEXF graph file (using the dedicated\n * graphology parser), and display it with some basic map features: Zoom in and\n * out buttons, reset zoom button, and a slider to increase or decrease the\n * quantity of labels displayed on screen.\n */\n\nimport Sigma from \"sigma\";\nimport Graph from \"graphology\";\nimport { parse } from \"graphology-gexf/browser\";\nimport { Coordinates, EdgeDisplayData, NodeDisplayData } from \"sigma/types\";\n\n// Load external GEXF file:\nfetch(\"./fruchHighGrav4.gexf\")\n  .then((res) => res.text())\n  .then((gexf) => {\n    // Parse GEXF string:\n    const graph = parse(Graph, gexf);\n\n    // Retrieve some useful DOM elements:\n    const container = document.getElementById(\"sigma-container\") as HTMLElement;\n    const zoomInBtn = document.getElementById(\"zoom-in\") as HTMLButtonElement;\n    const zoomOutBtn = document.getElementById(\"zoom-out\") as HTMLButtonElement;\n    const zoomResetBtn = document.getElementById(\n      \"zoom-reset\"\n    ) as HTMLButtonElement;\n    const labelsThresholdRange = document.getElementById(\n      \"labels-threshold\"\n    ) as HTMLInputElement;\n    const searchInput = document.getElementById(\n      \"search-input\"\n    ) as HTMLInputElement;\n    const searchSuggestions = document.getElementById(\n      \"suggestions\"\n    ) as HTMLDataListElement;\n\n    // Instanciate sigma:\n    const renderer = new Sigma(graph, container, {\n      minCameraRatio: 0.01,\n      maxCameraRatio: 3,\n      allowInvalidContainer: true,\n      renderEdgeLabels: true\n    });\n    const camera = renderer.getCamera();\n\n    // Bind zoom manipulation buttons\n    zoomInBtn.addEventListener(\"click\", () => {\n      camera.animatedZoom({ duration: 600 });\n    });\n    zoomOutBtn.addEventListener(\"click\", () => {\n      camera.animatedUnzoom({ duration: 600 });\n    });\n    zoomResetBtn.addEventListener(\"click\", () => {\n      camera.animatedReset({ duration: 600 });\n    });\n\n    // Type and declare internal state:\n    interface State {\n      hoveredNode?: string;\n      searchQuery: string;\n\n      // State derived from query:\n      selectedNode?: string;\n      suggestions?: Set<string>;\n\n      // State derived from hovered node:\n      hoveredNeighbors?: Set<string>;\n    }\n    const state: State = { searchQuery: \"\" };\n\n    // Feed the datalist autocomplete values:\n    searchSuggestions.innerHTML = graph\n      .nodes()\n      .map(\n        (node) =>\n          `<option value=\"${graph.getNodeAttribute(node, \"label\")}\"></option>`\n      )\n      .join(\"\\n\");\n\n    // Actions:\n    function setSearchQuery(query: string) {\n      state.searchQuery = query;\n\n      if (searchInput.value !== query) searchInput.value = query;\n\n      if (query) {\n        const lcQuery = query.toLowerCase();\n        const suggestions = graph\n          .nodes()\n          .map((n) => ({\n            id: n,\n            label: graph.getNodeAttribute(n, \"label\") as string\n          }))\n          .filter(({ label }) => label.toLowerCase().includes(lcQuery));\n\n        // If we have a single perfect match, them we remove the suggestions, and\n        // we consider the user has selected a node through the datalist\n        // autocomplete:\n        if (suggestions.length === 1 && suggestions[0].label === query) {\n          state.selectedNode = suggestions[0].id;\n          setHoveredNode(suggestions[0].id)\n          state.suggestions = undefined;\n          clickMode = true\n          clickedNode = suggestions[0].id\n\n          // Move the camera to center it on the selected node:\n          const nodePosition = renderer.getNodeDisplayData(\n            state.selectedNode\n          ) as Coordinates;\n          renderer.getCamera().animate(nodePosition, {\n            duration: 500\n          });\n        }\n        // Else, we display the suggestions list:\n        else {\n          state.selectedNode = undefined;\n          state.suggestions = new Set(suggestions.map(({ id }) => id));\n        }\n      }\n      // If the query is empty, then we reset the selectedNode / suggestions state:\n      else {\n        state.selectedNode = undefined;\n        state.suggestions = undefined;\n      }\n\n      // Refresh rendering:\n      renderer.refresh();\n    }\n\n    function setHoveredNode(node?: string) {\n      if (node) {\n        state.hoveredNode = node;\n        state.hoveredNeighbors = new Set(graph.neighbors(node));\n      } else {\n        state.hoveredNode = undefined;\n        state.hoveredNeighbors = undefined;\n      }\n\n      // Refresh rendering:\n      renderer.refresh();\n    }\n\n    // Bind search input interactions:\n    searchInput.addEventListener(\"input\", () => {\n      setSearchQuery(searchInput.value || \"\");\n    });\n    searchInput.addEventListener(\"blur\", () => {\n      setSearchQuery(\"\");\n    });\n\n    var clickedNode = undefined;\n    var clickMode = false;\n    // Bind graph interactions:\n    renderer.on(\"clickNode\", ({ node }) => {\n      if (clickedNode === node) {\n        clickedNode = undefined;\n        setHoveredNode(undefined);\n        clickMode = false;\n      } else {\n        clickedNode = node;\n        clickMode = true;\n        setHoveredNode(node);\n      }\n    });\n    renderer.on(\"enterNode\", ({ node }) => {\n      if (clickMode === false) {\n        setHoveredNode(node);\n      }\n    });\n    renderer.on(\"leaveNode\", ({ node }) => {\n      if (clickMode === false) {\n        if (clickedNode !== node) {\n          setHoveredNode(undefined);\n        }\n      }\n    });\n    renderer.on(\"doubleClickNode\", ({ node }) => {\n      window.open(\"https://www.opensecrets.org/search?q=\" + node);\n    });\n\n    renderer.setSetting(\"nodeReducer\", (node, data) => {\n      const res: Partial<NodeDisplayData> = { ...data };\n\n      if (\n        state.hoveredNeighbors &&\n        !state.hoveredNeighbors.has(node) &&\n        state.hoveredNode !== node\n      ) {\n        res.label = \"\";\n        res.color = \"#f6f6f6\";\n      }\n\n      if (state.selectedNode === node) {\n        res.highlighted = true;\n      } else if (state.suggestions && !state.suggestions.has(node)) {\n        res.label = \"\";\n        res.color = \"#f6f6f6\";\n      }\n\n      if (state.suggestions && state.suggestions.has(node)) {\n        res.highlighted = true;\n        res.label = graph.getNodeAttribute(node, \"label\")\n        res.color = graph.getNodeAttribute(node, \"color\")\n      }\n\n      return res;\n    });\n\n    // Render edges accordingly to the internal state:\n    // 1. If a node is hovered, the edge is hidden if it is not connected to the\n    //    node\n    // 2. If there is a query, the edge is only visible if it connects two\n    //    suggestions\n    renderer.setSetting(\"edgeReducer\", (edge, data) => {\n      const res: Partial<EdgeDisplayData> = { ...data };\n\n      if (state.hoveredNode && !graph.hasExtremity(edge, state.hoveredNode)) {\n        res.hidden = true;\n      }\n\n      if (\n        state.suggestions &&\n        (!state.suggestions.has(graph.source(edge)) ||\n          !state.suggestions.has(graph.target(edge)))\n      ) {\n        res.hidden = true;\n      }\n\n      return res;\n    });\n  });\n"],"sourceRoot":""}